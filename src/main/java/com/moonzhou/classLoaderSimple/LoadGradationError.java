package com.moonzhou.classLoaderSimple;

/**
 * 错误的加载示例
 * 
 * 初始化阶段是执行类构造器<clinit>()方法的过程.
 *
 * clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，
 * 编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，
 * 定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
 * 
 * <clinit>()方法与实例构造器<init>()方法不同，它不需要显示地调用父类构造器，
 * 虚拟机会保证在子类<init>()方法执行之前，父类的<clinit>()方法方法已经执行完毕。
 * 由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。
 * <clinit>()方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产<clinit>()方法。
 * 
 * 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。
 * 但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。
 * 只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。
 * 
 * @author moon-zhou
 *
 */
public class LoadGradationError {
    /*static {
        i = 0;
        System.out.println(i); // 这句编译器会报错：Cannot reference a field before it is defined（非法向前应用）
    }
    static int i = 1;*/
}
